* Order

juxty -> evolved -> grown -> ascended

* Juxty

Record based illustrations

* Juxty Evolved

cmd and event handlers
cmd synchronous returns on apply event


* Juxty Grown

cmd writes an event and returns (decoupled)
event processing async
consistency errors

* Juxty Evolved

event processing async
local pending state
consistency fixed

* Notes

1. cmd handler must write an event
2. when the event is written state is guaranteed to change at some point in the future
3. choice:
   - a. cmd handler can wait for the state change and return the cmd result (juxty evolved)
   - b. cmd handler can return the cmd result (juxty grown)

** 3a
- simple synchronous reasoning
- always consistent
- state change is only on cmd handling
  - separate hydration mechanism required or problematic cmd replay

** 3b
- more complex asynchronous reasoning
- care must be taken to maintain consistency
  - juxty grown highlights inconsistency
  - juxty ascended shows a fix, pending state store or alternately (cmd state) vs (event state)
    cmd state need not be the full "aggregate"
    event state probably is

    
Between the 2 components we have shared state

* Aggregate Root


** Entities
** Value Objects
** Repositories
** Aggregates
** Domain Events

#+begin_src clojure
{:juxty {:position 0
         :top-half :box
         :bottom-half :wheels}
#+end_src

